## 1.1.1 자바스트립트의 데이터 타입

### 원시 타입

-   boolean
-   null
-   undefined
-   number
-   string
-   symbol
-   bigint

### 객체 타입

-   object

## 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 바로 값을 저장하는 방식의 차이다
이 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원인이 된다.

원시 타입은 불변 형태의 값으로 저장된다.
이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.

```jsx
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true
```

hi에 hello가 복사해 전달됐기 때문에 당연 true가 반환된다.

반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며,
값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

```jsx
var hello = {
    greet: "hello world",
};

var hi = {
    greet: "hello world",
};

// 동등 비교를 하면 false가 나온다
console.log(hello === hi);

// 원시값인 내부 속성값을 비교하면 동일하다
console.log(hello.greet === hi.greet);
```

객체는 값을 저장하는 게 아니라 참조를 저장하기 때문에 앞서 동일하게 선언했던 객체라 하더라도
저장하는 순간 다른 참조를 바라보기 때문에 false를 반환하게 된다.

## 자바스크립트의 또 다른 비교 공식, Object.is

Object.is는 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 변환하는 메서드다.
Object.isdhk ==나 ===와 다른 점은 다음과 같다

```jsx
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

한 가지 주의해야 할 점은, Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다.
객체 비교는 앞서 이야기한 객체 비교 원리와 동등하다.

## 리액트에서의 동등 비교

리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 Object.is이다.

리액트에서의 비교를 요약하자면 Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교,
즉 객체 간 얕은 비교를 한 번 더 수행하는 것을 알 수 있다.
객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

얕은 비교까지만 규현한 이유는 리액트에서 사용하는 JSX.props는 객체이고,
그리고 여기에 있는 props만 일차적으로 비교하면 되기 때문이다.

## 정리

자바스크립트에서 객체 비교의 불완정성은 스칼라나 하스켈 등의 다른 함수형 언어에서는 볼 수 없는 특징으로,
자바스크립트 개발자라면 반드시 기억해 두어야 한다.
이러한 자바스크립트를 기반으로 한 리액트의 함수형 프로그래밍 모델에서도 이러한 언어적인 한계를 뛰어넘을 수 없으므로
얕은 비교만을 사용해 비교를 수행해 필요한 기능을 구현하고 있다.
