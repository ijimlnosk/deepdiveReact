# 1.2 함수

## 1.2.1 함수란 무엇인가?

함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.

```jsx
// 함수의 기본적인 형태
function sum(a, b) {
    return a + b;
}
```

## 1.2.2 함수를 정의하는 4가지 방법

### 함수 선언문

자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식이다.

```jsx
function add(a, b) {
    return a + b;
}
```

함수 선언문은 표현식이 아닌 일반 문으로 분류된다.
표현식이란 무언가 값을 산출하는 구문을 의미한다.

```jsx
cosnt sum = function sum(a,b){
    return a + b
}

sum(10, 24) // 34
```

위 예제는 마치 sum이라는 변수에 함수 sum을 할당하는 표현식과 같은 작동을 보였다.
이는 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문이다.
따라서 위와 같이 이름을 가진 형태의 함수 리터럴은 코드 문맥에 따라 전자와 같은 선언문으로도,
후자와 같은 표현식으로도 사용될 수 있음을 알고 있어야 한다.

### 함수 표현식

함수 표현식에 대해 알아보기 전에 '일급 객체'라는 개념을 알고 있어야 한다
프로그래밍 세계에서 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
자바스크립트에서 함수는 일급 객체다.
함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며,
앞에서 본 것처럼 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.

```jsx
// 함수가 일급 객체라고 했으니, 함수를 변수에 할당하는 것은 당연히 가능하다
const sum = function (a, b) {
    return a + b;
};

sum(10, 24); // 34
```

함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다.
코드를 봤을 때 혼란을 방지하기 위함이다.

### 함수 표현식과 선인 식의 차이

이 두 가지 방식의 가장 큰 차이는 호이스팅 여부다

#### 호이스팅이란

함수 선언문이 마치 코드 맨 앞단에 작성된 거처럼 작동하는 자바스크립트의 특징을 의미한다.

```jsx
hello(); // hello

function hello() {
    console.log("hello");
}

hello(); // hello
```

함수를 선언한 hello는 코드 중간에 있음에도 불구하고,
맨 앞에서 호출한 hello()는 어떠한 에러도 없이 정상적인 함수의 작동을 수행하는 것을 알 수 있다.

함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다.

반면 함수 표현식은 함수를 변수에 할당했다.
변수도 마찬가지로 호이스팅이 발생한다.
그러나 함수의 호이스팅과는 다르게 호이스팅되는 시점에서 var의 경우에는 undefined로 초기화한다는 차이가 있다.

```jsx
console.log(typeof hello === "undefined"); // true

hello(); // Uncaught TypeError: hello is not a function

var hello = function () {
    console.log("hello");
};

hello();
```

### Function 생성자

```jsx
const add = new Function("a", "b", "return a + b");

add(10, 24); // 34
```

생성자 함수 방식으로 함수를 만드는 것은 권장되지 않는다.

### 화살표 함수

function 이라는 키워드 대신 => 라는 화살표를 활용해서 함수를 만든다.

```jsx
const add = (a, b) => {
    return a + b;
};

const add = (a, b) => a + b;
```

화살표 함수는 constructor를 사용할 수 없다.
즉, 생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.

```jsx
const Car = (name) => {
    this.name = name;
};

// Uncaught TypeError: Car is not a constructor
const myCar = new Car("하이");
```

그리고 화살표 함수에서는 arguments가 존재하지 않는다.

```jsx
function hello() {
    console.log(arguments);
}

/// Arguments(3) [1,2,3,callee: f, Symbol(Symbol.iterator):f]
hello(1, 2, 3);

const hi = () => {
    console.log(argument);
};

// Uncaught TypeError: argument is not defined
hi(1, 2, 3);
```

그리고 화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다.

#### this란?

자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
이 this는 화살표 함수 이전까지는 함수를 정의할 때 결저오디는 것이 아니라,
함수가 어떻게 호출되느냐에 따라 동적으로 결정된다.
만약 함수가 일반 함수로서 호출된다면, 그 내부의 this는 전역 객체를 가리키게 된다.

화살표 함수는 함수 자체의 바인딩을 갖지 않는다.
화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.

## 1.2.3 다양한 함수 살펴보기

### 즉시 실행 함수

함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다.
단 한 번만 호출되고 다시금 호출할 수 없는 함수다.

```jsx
(function (a, b) {
    return a + b;
})(10, 24)(
    // 34

    (a, b) => {
        return a + b;
    },
    (10, 24)
); // 34
```

즉시 실행 함수는 한 번 선언하고 호출된 이후부터는 더 이상 재호출이 불가능하다.

### 고차 함수

자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다.
이런 역할을 하는 함수를 고차함수라고 한다.

```jsx
// 함수를 매개변수로 받는 대표적인 고차함수, Array.prototype.map
const doubledArray = [1, 2, 3].map((itme) => itme * 2);

doubledArray; // [2,4,6]

// 함수를 반환하는 고차 함수의 예
const add = function (a) {
    // a가 존재하는 클로저를 생성
    return function (b) {
        // b를 인수로 받아 두 합을 반환하는 또 다른 함수르 ㄹ생성
        return a + b;
    };
};

add(1)(3); // 4
```

## 1.2.4 함수를 만들 때 주의해야 할 사항

### 함수의 부수 효과를 최대한 억제하라

함수의 부수 효과(side-effect)란
함수 내의 작동으로 인해 삼수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다.
이러한 부수 효과가 없는 함수를 순수 함수라 하고, 부수 효과가 존재하는 함수를 비순수 함수라고 한다.

```jsx
function PureComponent(props) {
    const { a, b } = props;
    return <div>{a + b}</div>;
}
```

### 가능한 한 함수를 작게 만들어라

### 누구나 이해할 수 있는 이름을 붙여라
